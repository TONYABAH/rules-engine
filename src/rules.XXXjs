import Engine from './core/engine'
import Compiler from './core/compiler'
import Validator from './core/validator' // Validation
import Translator from './core/translator'
import choice from './core/choice'
import languageModules from './core/languageModules'
import ErrorKeys from './translation/keys'
import CustomErrors from './core/custom-errors'

class Rules {
  constructor (locale = 'en') {
    this.locale = locale  
    this.languageModule = languageModules[locale]
    this.compiler = new Compiler(this.locale, this.languageModule)
    this.translator = new Translator(languageModules, this.locale)
    this.validator = new Validator(this.translator, this.locale)
  }
  static registerLanguage (lang, data) {
    const language = lang.toLocaleLowerCase()
    if (arguments.length < 2) {
      throw new Error('Language name required')
    }
    if (!data) {
      throw new Error('Language data required')
    }
    if (typeof language !== 'string') {
      throw new Error('Language name should be a String')
    }
    if (language.length > 2) {
      throw new Error('Language code should contain only two characters')
    }
    if (!language.match(/[a-z][a-z]/)) {
      throw new Error('Unknown character in language code')
    }
    if (languageModules[language]) {
      throw new Error('Language already installed')
    }
    languageModules[language] = data
    // console.log(languageModule)
    // return this
  }
  init (language) {
    this.languageModule = languageModules[language]
    this.validator = new Validator(language)
    this.compiler = new Compiler(language, this.languageModule)
    this.translator = new Translator(this.languageModule)
   
    return this
  }
  async parse (codes) {
    const errors = await this.compiler.parse(codes)
    return errors
  }
  async compile (codes) {
   
    const data = await this.compiler.compile(codes)
    const errors = this.compiler.errors
    if (errors && errors.length > 0) {
      Promise.reject(errors)
    } else {
      return data
    }
  }
  repeat (data) {
    if (!data) {
      return this.raiseValidationError(ErrorKeys.KnowledgebaseNotFound)
    }
    return this.run(data)
  }
  run (data) {
    if (!data) {
      return this.raiseValidationError(ErrorKeys.KnowledgebaseNotFound)
    }
    let response = new Engine(data, this.translator, this.validator).run()
    return this.process(response)
  }
  reply (data, input) {
    if (!data) {
      return this.raiseValidationError(ErrorKeys.KnowledgebaseNotFound)
    }
    if (!input || input.toString().trim().length === 0) {
      return this.raiseValidationError(ErrorKeys.NoInput)
    }
    let response = new Engine(data, this.translator, this.validator
      ).input(input)
    return this.process(response)
  }
  process (response) {
    if (response) return response
    if (response.Label === 'Prompt' || response.Label === 'CF') {//Prompting for input
      return ({ type: 'prompt', data: response })
    } else if (response instanceof Array) {//answers are ready
      return ({ type: 'answers', data: response })
    } else {
      return response
    }
  }
  validate (input, prompt) {
    return this.validator.validate(input, prompt)
  }
  choice (input, prompt) {
    return choice(input, prompt, this.locale)
  }
  translate (code, to) {
    return this.translator.translate(code, to)
  }
  translatePlain (text, to, from) {
    return this.translator.translatePlain(text, to, from)
  }
  raiseValidationError (code) {
    // const message = this.t(code)
    const err = CustomErrors(this.translator, this.locale).ValidationError(code)
    return err
  }
  raiseSecurityError (key) {
    // const message = this.t(code, language)
    const err = CustomErrors(this.translator, this.locale).SecurityError(key)
    return err
  }
}

export default Rules
